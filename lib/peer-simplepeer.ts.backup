import SimplePeer from 'simple-peer';
import { getTURNServers } from './turn-config';
import { getCurrentWorker, getNextWorker, resetWorkerPool, markWorkerFailed } from './cloudflare-workers-pool';

let ws: WebSocket | null = null;
let myId: string | null = null;
let peer: SimplePeer.Instance | null = null;
let remotePeerId: string | null = null;
let storedOnMessage: ((peerId: string, data: string) => void) | null = null;
let storedOnConnect: ((remotePeerId?: string) => void) | null = null;
let storedOnDisconnect: ((reason?: string) => void) | undefined = undefined;
let p2pEstablished = false; // è·Ÿè¸ªP2Pè¿æ¥æ˜¯å¦çœŸæ­£å»ºç«‹è¿‡
let heartbeatInterval: NodeJS.Timeout | null = null; // å¿ƒè·³å®šæ—¶å™¨
let reconnectAttempts = 0; // é‡è¿å°è¯•æ¬¡æ•°
let maxReconnectAttempts = 3; // æœ€å¤§é‡è¿æ¬¡æ•°
let currentWorkerUrl = ''; // å½“å‰ worker URL
let resolveConnection: ((value: string | null) => void) | null = null; // ä¿å­˜è¿æ¥ resolve å‡½æ•°ç”¨äºåå°æ¢å¤

// å…¨å±€è°ƒè¯•ä¿¡æ¯æ”¶é›†å™¨
export const debugInfo: string[] = [];
function addDebug(msg: string) {
  const timestamp = new Date().toLocaleTimeString();
  debugInfo.push(`[${timestamp}] ${msg}`);
  if (debugInfo.length > 50) debugInfo.shift(); // åªä¿ç•™æœ€è¿‘ 50 æ¡
  console.log(`[DEBUG] ${msg}`);
}

// å°†è°ƒè¯•ä¿¡æ¯æš´éœ²åˆ° window å¯¹è±¡ï¼Œæ–¹ä¾¿ç•Œé¢è®¿é—®
if (typeof window !== 'undefined') {
  (window as any).getDebugInfo = () => debugInfo;
  (window as any).printDiagnosticReport = async () => {
    const { printDiagnosticReport } = await import('./turn-test');
    printDiagnosticReport();
  };
  (window as any).testTURNServers = async () => {
    const { getTURNServers } = await import('./turn-config');
    const { testAllTURNServers } = await import('./turn-test');
    console.log('ğŸ§ª å¼€å§‹æµ‹è¯• TURN æœåŠ¡å™¨...');
    const results = await testAllTURNServers(getTURNServers());
    console.table(results);
    return results;
  };
}

// ä¿å­˜ ID åˆ° localStorageï¼Œé˜²æ­¢åå°åˆ‡æ¢å ID ä¸¢å¤±
function saveId(id: string) {
  try {
    localStorage.setItem('ghostchat_peer_id', id);
    localStorage.setItem('ghostchat_peer_id_timestamp', Date.now().toString());
    console.log('[SIMPLEPEER] ğŸ’¾ ID å·²ä¿å­˜åˆ° localStorage:', id);
  } catch (e) {
    console.warn('[SIMPLEPEER] æ— æ³•ä¿å­˜ ID åˆ° localStorage:', e);
  }
}

// ä» localStorage æ¢å¤ ID
function getSavedId(): string | null {
  try {
    const savedId = localStorage.getItem('ghostchat_peer_id');
    const timestamp = localStorage.getItem('ghostchat_peer_id_timestamp');
    if (savedId && timestamp) {
      const age = Date.now() - parseInt(timestamp);
      const maxAge = 5 * 60 * 1000; // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
      if (age < maxAge) {
        console.log('[SIMPLEPEER] ğŸ“‚ ä» localStorage æ¢å¤ ID:', savedId, `(å¹´é¾„: ${Math.floor(age/1000)}ç§’)`);
        return savedId;
      } else {
        console.log('[SIMPLEPEER] ğŸ“‚ ä¿å­˜çš„ ID å·²è¿‡æœŸï¼Œæ¸…é™¤');
        localStorage.removeItem('ghostchat_peer_id');
        localStorage.removeItem('ghostchat_peer_id_timestamp');
      }
    }
  } catch (e) {
    console.warn('[SIMPLEPEER] æ— æ³•ä» localStorage è¯»å– ID:', e);
  }
  return null;
}

// å¯åŠ¨ WebSocket å¿ƒè·³ï¼Œä¿æŒè¿æ¥æ´»è·ƒ
function startHeartbeat() {
  stopHeartbeat(); // å…ˆæ¸…é™¤ä¹‹å‰çš„å¿ƒè·³

  // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´çŸ­çš„å¿ƒè·³é—´éš”ï¼ˆ15ç§’ï¼‰ï¼Œæ¡Œé¢ç«¯ä½¿ç”¨ 20 ç§’
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const interval = isMobile ? 15000 : 20000;

  console.log('[SIMPLEPEER] Starting heartbeat (interval:', interval / 1000, 's)');

  heartbeatInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({ type: 'PING' }));
        console.log('[SIMPLEPEER] Sent PING to server');
      } catch (err) {
        console.error('[SIMPLEPEER] Error sending PING:', err);
        stopHeartbeat();
      }
    } else {
      console.log('[SIMPLEPEER] WebSocket not open, stopping heartbeat');
      stopHeartbeat();
    }
  }, interval);
}

// åœæ­¢å¿ƒè·³
function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    console.log('[SIMPLEPEER] Heartbeat stopped');
  }
}

async function tryConnectWorker(
  workerUrl: string,
  onMessage: (peerId: string, data: string) => void,
  onConnect: (remotePeerId?: string) => void,
  onDisconnect?: (reason?: string) => void
): Promise<string | null> {
  storedOnMessage = onMessage;
  storedOnConnect = onConnect;
  storedOnDisconnect = onDisconnect;
  currentWorkerUrl = workerUrl;

  return new Promise((resolve, reject) => {
    // ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„ IDï¼Œé˜²æ­¢åå°åˆ‡æ¢å¯¼è‡´ ID å˜åŒ–
    const savedId = getSavedId();
    myId = savedId || Math.random().toString(36).substr(2, 9);

    if (savedId) {
      addDebug(`ğŸ”„ ä½¿ç”¨ä¿å­˜çš„ ID: ${myId}`);
    } else {
      addDebug(`ğŸ†• ç”Ÿæˆæ–° ID: ${myId}`);
    }

    addDebug(`æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨: ${workerUrl}`);
    console.log('[SIMPLEPEER] Trying worker:', workerUrl);
    ws = new WebSocket(`${workerUrl}?key=peerjs&id=${myId}&token=token`);
    
    ws.onopen = () => {
      addDebug(`âœ… WebSocket å·²è¿æ¥ï¼Œæˆ‘çš„ ID: ${myId}`);
      console.log('[SIMPLEPEER] WebSocket connected, ID:', myId);

      // è¿æ¥æˆåŠŸåä¿å­˜ ID
      if (myId) {
        saveId(myId);
      }

      resolve(myId!);
    };

    ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        console.log('[SIMPLEPEER] Received message type:', msg.type, 'from:', msg.src);

        if (msg.type === 'OPEN') {
          console.log('[SIMPLEPEER] Server acknowledged');
          // ç«‹å³å‘é€ç¬¬ä¸€ä¸ª PINGï¼Œä¿æŒ WebSocket è¿æ¥æ´»è·ƒ
          try {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'PING' }));
              console.log('[SIMPLEPEER] Sent initial PING immediately');
            }
          } catch (err) {
            console.error('[SIMPLEPEER] Error sending initial PING:', err);
          }
          // å¯åŠ¨å®šæœŸå¿ƒè·³
          startHeartbeat();
          return;
        }

        if (msg.type === 'PONG') {
          console.log('[SIMPLEPEER] Received PONG from server');
          return;
        }

        if (msg.type === 'SIGNAL' && msg.signal) {
          const signalType = msg.signal.type || 'unknown';
          console.log('[SIMPLEPEER] Signal received from:', msg.src, 'type:', signalType, 'peer exists:', !!peer);
          addDebug(`ğŸ“¥ æ”¶åˆ° signal: ${signalType}ï¼Œæ¥æº: ${msg.src}`);

          if (!peer) {
            console.log('[SIMPLEPEER] Creating new peer for incoming connection from:', msg.src);
            addDebug(`ğŸ†• åˆ›å»ºæ–° peerï¼ˆå“åº”æ–¹ï¼‰`);
            remotePeerId = msg.src;

            // ç§»åŠ¨ç«¯æ£€æµ‹å’Œé…ç½®
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('[SIMPLEPEER] Device type:', isMobile ? 'MOBILE' : 'DESKTOP');

            const turnServers = getTURNServers();
            console.log('[SIMPLEPEER] Creating peer (initiator: false)');
            console.log('[SIMPLEPEER] ICE transport policy:', isMobile ? 'relay (mobile)' : 'all (desktop)');
            console.log('[SIMPLEPEER] ICE candidate pool size:', isMobile ? 10 : 5);
            console.log('[SIMPLEPEER] ICE complete timeout:', isMobile ? 60000 : 45000);
            console.log('[SIMPLEPEER] TURN servers:', turnServers.length);

            peer = new SimplePeer({
              initiator: false,
              config: {
                iceServers: turnServers
              },
              trickle: true
            });

            setupPeer(peer, storedOnMessage!, storedOnConnect!, storedOnDisconnect, msg.src);
          }

          try {
            peer.signal(msg.signal);
            addDebug(`âœ… Signal å·²åº”ç”¨åˆ° peer`);
            console.log('[SIMPLEPEER] Signal processed, peer state:', peer.connected ? 'connected' : 'connecting');
          } catch (signalErr) {
            addDebug(`âŒ Signal åº”ç”¨å¤±è´¥: ${signalErr}`);
            console.error('[SIMPLEPEER] Error applying signal:', signalErr);
          }
        }
      } catch (err) {
        console.error('[SIMPLEPEER] Error processing message:', err);
      }
    };
    
    ws.onerror = (err) => {
      // è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
      const event = err as Event;
      console.error('[SIMPLEPEER] WebSocket error:', {
        type: event.type,
        target: (event.target as WebSocket)?.url,
        readyState: (event.target as WebSocket)?.readyState,
        bufferedAmount: (event.target as WebSocket)?.bufferedAmount
      });
      // ç§»åŠ¨ç«¯å¸¸è§é—®é¢˜ï¼šç½‘ç»œåˆ‡æ¢å¯¼è‡´ WebSocket å…³é—­
      console.error('[SIMPLEPEER] Error details - å¯èƒ½æ˜¯ç§»åŠ¨ç«¯ç½‘ç»œåˆ‡æ¢å¯¼è‡´çš„è¿æ¥æ–­å¼€');
      reject(err);
    };

    ws.onclose = (event) => {
      console.log('[SIMPLEPEER] WebSocket closed:', {
        code: event.code,
        reason: event.reason || 'none',
        wasClean: event.wasClean,
        p2pEstablished,
        peerExists: !!peer,
        peerConnected: peer?.connected || false
      });
      stopHeartbeat(); // åœæ­¢å¿ƒè·³

      // åªæœ‰åœ¨ P2P è¿æ¥å·²å»ºç«‹çš„æƒ…å†µä¸‹æ‰è°ƒç”¨ disconnect
      // å¦‚æœåªæ˜¯ WebSocket å…³é—­ä½† P2P è¿˜æ²¡è¿æ¥ï¼Œä¸è¦è§¦å‘ disconnect
      if (p2pEstablished) {
        console.log('[SIMPLEPEER] P2P was established, calling disconnect');
        if (peer) peer.destroy();
        if (storedOnDisconnect) storedOnDisconnect('peer-left');
      } else if (peer) {
        // å¦‚æœ peer å­˜åœ¨ä½† P2P æœªå»ºç«‹ï¼Œè¯´æ˜è¿æ¥å°è¯•å¤±è´¥äº†
        console.error('[SIMPLEPEER] WebSocket closed before P2P connection established');
        peer.destroy();
        if (storedOnDisconnect) storedOnDisconnect('connection-failed');
      } else {
        // ç§»åŠ¨ç«¯è‡ªåŠ¨é‡è¿ï¼šå¦‚æœ WebSocket å…³é—­ä½† P2P æœªå»ºç«‹ï¼Œå°è¯•é‡è¿
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile && reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          console.log(`[SIMPLEPEER] ç§»åŠ¨ç«¯è‡ªåŠ¨é‡è¿ (${reconnectAttempts}/${maxReconnectAttempts})...`);

          // å»¶è¿Ÿåé‡è¿
          setTimeout(async () => {
            try {
              console.log('[SIMPLEPEER] å°è¯•é‡æ–°è¿æ¥...');
              const newId = await tryConnectWorker(currentWorkerUrl, storedOnMessage!, storedOnConnect!, storedOnDisconnect);
              if (newId) {
                console.log('[SIMPLEPEER] é‡è¿æˆåŠŸ!');
                reconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°
              }
            } catch (err) {
              console.error('[SIMPLEPEER] é‡è¿å¤±è´¥:', err);
            }
          }, 2000); // 2ç§’åé‡è¿
        } else if (!isMobile) {
          console.log('[SIMPLEPEER] WebSocket closed but no peer created yet (desktop)');
        } else {
          console.error('[SIMPLEPEER] ç§»åŠ¨ç«¯é‡è¿å·²è¾¾æœ€å¤§æ¬¡æ•°ï¼Œæ”¾å¼ƒé‡è¿');
        }
      }
    };

    // ç§»åŠ¨ç«¯ç½‘ç»œå¯èƒ½è¾ƒæ…¢ï¼Œå¢åŠ è¶…æ—¶æ—¶é—´åˆ° 45 ç§’
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const timeout = isMobile ? 45000 : 20000;
    setTimeout(() => {
      if (ws?.readyState !== WebSocket.OPEN) {
        reject(new Error('Worker timeout'));
      }
    }, timeout);
  });
}

export async function initSimplePeer(
  onMessage: (peerId: string, data: string) => void,
  onConnect: (remotePeerId?: string) => void,
  onDisconnect?: (reason?: string) => void
): Promise<string | null> {
  resetWorkerPool();
  reconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°

  let currentWorker = getCurrentWorker();

  while (currentWorker) {
    try {
      const id = await tryConnectWorker(currentWorker, onMessage, onConnect, onDisconnect);
      console.log('[SIMPLEPEER] Connected to worker:', currentWorker);
      return id;
    } catch (err) {
      console.warn('[SIMPLEPEER] Worker failed:', currentWorker, err);
      // æ ‡è®°å½“å‰ worker ä¸ºå¤±è´¥
      markWorkerFailed();
      const nextWorker = getNextWorker();
      if (!nextWorker) {
        throw new Error('All Cloudflare Workers failed');
      }
      currentWorker = nextWorker;
    }
  }
  
  throw new Error('No workers available');
}

function setupPeer(
  p: SimplePeer.Instance,
  onMessage: (peerId: string, data: string) => void,
  onConnect: (remotePeerId?: string) => void,
  onDisconnect?: (reason?: string) => void,
  targetPeerId?: string
) {
  let disconnectCalled = false;
  let iceTimeout: NodeJS.Timeout | null = null;
  let connectionTimeout: NodeJS.Timeout | null = null;
  let eventLog: string[] = [];

  addDebug(`â³ setupPeer å·²è°ƒç”¨`);
  addDebug(`ğŸ“‹ å¼€å§‹æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨...`);

  const logEvent = (eventName: string) => {
    eventLog.push(`${eventName} (${new Date().toLocaleTimeString()})`);
    addDebug(`ğŸ“¨ äº‹ä»¶: ${eventName}`);
  };

  const callDisconnect = (reason: string) => {
    if (!disconnectCalled && onDisconnect) {
      disconnectCalled = true;
      addDebug(`âŒ è¿æ¥æ–­å¼€: ${reason}`);
      addDebug(`ğŸ“Š å·²è§¦å‘äº‹ä»¶: ${eventLog.join(', ')}`);
      if (iceTimeout) clearTimeout(iceTimeout);
      if (connectionTimeout) clearTimeout(connectionTimeout);
      onDisconnect(reason);
    }
  };

  // æ³¨å†Œæ‰€æœ‰å¯èƒ½çš„äº‹ä»¶
  const events = ['signal', 'connect', 'close', 'error', 'data', 'pause', 'resume', 'iceStateChange', 'iceCandidate', 'negotiationNeeded'];
  events.forEach(eventName => {
    try {
      (p as any).on(eventName, (...args: any[]) => {
        if (eventName === 'signal') {
          // signal äº‹ä»¶å•ç‹¬å¤„ç†
          return;
        }
        logEvent(eventName);
      });
    } catch (e) {
      addDebug(`âŒ æ— æ³•æ³¨å†Œäº‹ä»¶ ${eventName}: ${e}`);
    }
  });

  p.on('signal', (signal) => {
    logEvent('signal');
    const signalType = signal.type || 'unknown';
    addDebug(`ğŸ“¡ Signal äº‹ä»¶è§¦å‘: ${signalType}`);

    if (signalType === 'offer') {
      const signalStr = JSON.stringify(signal);
      addDebug(`ğŸ“¤ å‘é€ offer (å¤§å°: ${signalStr.length} å­—èŠ‚)`);
    } else if (signalType === 'answer') {
      const signalStr = JSON.stringify(signal);
      addDebug(`ğŸ“¥ æ”¶åˆ° answer (å¤§å°: ${signalStr.length} å­—èŠ‚)`);
    } else if (signalType === 'candidate') {
      const candidate = (signal as any).candidate;
      if (candidate) {
        // è§£æ candidate è·å–è¯¦ç»†ä¿¡æ¯
        addDebug(`ğŸ§Š ICE candidate åŸå§‹æ•°æ®: ${candidate.substring(0, 150)}...`);
      } else {
        addDebug(`ğŸ§Š ICE candidate: null (æ”¶é›†å®Œæˆ)`);
      }
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
      const dst = targetPeerId || remotePeerId || 'unknown';
      console.log('[SIMPLEPEER] Sending signal to:', dst, 'type:', signal.type || 'candidate', 'myId:', myId);
      const message = JSON.stringify({
        type: 'SIGNAL',
        src: myId,
        dst,
        signal
      });
      console.log('[SIMPLEPEER] Message payload:', message);
      ws.send(message);
    } else {
      console.error('[SIMPLEPEER] Cannot send signal - WebSocket not ready. State:', ws?.readyState);
    }
  });

  // é‡æ–°æ³¨å†Œå…·ä½“çš„äº‹ä»¶å¤„ç†å™¨ï¼ˆè¦†ç›–ä¸Šé¢çš„é€šç”¨æ³¨å†Œï¼‰
  p.on('connect', () => {
    logEvent('connect');
    addDebug(`ğŸ‰ P2P è¿æ¥æˆåŠŸï¼`);
    console.log('[SIMPLEPEER] P2P connected successfully');
    p2pEstablished = true; // æ ‡è®°P2Pè¿æ¥å·²å»ºç«‹
    if (iceTimeout) clearTimeout(iceTimeout);
    if (connectionTimeout) clearTimeout(connectionTimeout);
    onConnect(targetPeerId || remotePeerId || undefined);

    const pc = (p as any)._pc;
    if (pc) {
      pc.oniceconnectionstatechange = () => {
        const state = pc.iceConnectionState;
        console.log('[SIMPLEPEER] ICE connection state:', state);
        addDebug(`ğŸ§Š ICE çŠ¶æ€å˜åŒ–: ${state}`);
        if (state === 'disconnected' || state === 'failed') {
          console.error('[SIMPLEPEER] ICE failed or disconnected');
          console.error('[SIMPLEPEER] This usually means:');
          console.error('[SIMPLEPEER] - Both devices are behind VPNs/NAT');
          console.error('[SIMPLEPEER] - TURN servers are unreachable');
          console.error('[SIMPLEPEER] - Firewall is blocking UDP/TCP ports');
          callDisconnect('peer-left');
        } else if (state === 'connected') {
          console.log('[SIMPLEPEER] ICE connected successfully!');
          addDebug(`âœ… ICE è¿æ¥æˆåŠŸï¼`);
          // è·å–é€‰ä¸­çš„ ICE å€™é€‰
          const stats = pc.getStats();
          stats.then((statsReport: any) => {
            statsReport.forEach((report: any) => {
              if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                console.log('[SIMPLEPEER] Selected candidate pair:', report);
              }
              if (report.type === 'local-candidate' || report.type === 'remote-candidate') {
                console.log('[SIMPLEPEER]', report.type, ':', report.candidateType, report.protocol, report.address);
              }
            });
          }).catch((e: unknown) => console.log('[SIMPLEPEER] Could not get stats:', e));
        }
      };

      pc.onicegatheringstatechange = () => {
        const state = pc.iceGatheringState;
        console.log('[SIMPLEPEER] ICE gathering state:', state);
        addDebug(`ğŸ”„ ICE æ”¶é›†çŠ¶æ€: ${state}`);
      };

      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        console.log('[SIMPLEPEER] Connection state:', state);
        addDebug(`ğŸ”— WebRTC è¿æ¥çŠ¶æ€: ${state}`);
        if (state === 'failed') {
          console.error('[SIMPLEPEER] Connection failed - check browser console for ICE errors');
        }
      };

      // æ·»åŠ è¯¦ç»†çš„ ICE å€™é€‰æ”¶é›†æ—¥å¿—
      let candidateCount = 0;
      let candidateTypes: { [key: string]: number } = { host: 0, srflx: 0, relay: 0, prflx: 0 };
      let iceGatheringTimeout: NodeJS.Timeout | null = null;

      addDebug(`ğŸ“ å¼€å§‹ ICE å€™é€‰æ”¶é›†...`);

      // ICE æ”¶é›†è¶…æ—¶æ£€æµ‹ï¼ˆç§»åŠ¨ç«¯å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼‰
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      iceGatheringTimeout = setTimeout(() => {
        if (candidateCount === 0) {
          addDebug(`âš ï¸ ICE æ”¶é›†è¶…æ—¶ï¼ˆ${isMobile ? 60 : 30}ç§’ï¼‰ï¼Œæœªæ”¶é›†åˆ°ä»»ä½•å€™é€‰`);
          console.warn('[SIMPLEPEER] ICE gathering timeout - no candidates collected');
          addDebug(`ğŸ” è¯Šæ–­ä¿¡æ¯ï¼š`);
          addDebug(`  - ç§»åŠ¨ç«¯: ${isMobile}`);
          addDebug(`  - ICE æœåŠ¡å™¨æ•°é‡: ${(p as any)._pc?.config?.iceServers?.length || 'unknown'}`);
          addDebug(`  - ç½‘ç»œç±»å‹: ${((navigator as any).connection)?.effectiveType || 'unknown'}`);
        }
      }, isMobile ? 60000 : 30000);

      pc.onicecandidate = (event: any) => {
        if (event.candidate) {
          candidateCount++;
          const type = event.candidate.candidateType || 'unknown';
          const protocol = event.candidate.protocol || 'unknown';
          const address = event.candidate.address || 'unknown';
          const port = event.candidate.port || 'unknown';
          console.log(`[SIMPLEPEER] ICE candidate #${candidateCount}:`, type, protocol, `${address}:${port}`);
          addDebug(`ğŸ§Š ICE å€™é€‰ #${candidateCount}: ${type} ${protocol} ${address}:${port}`);
          if (type === 'relay') {
            candidateTypes.relay++;
            console.log('[SIMPLEPEER] âœ“ Using TURN relay (good for VPN!)');
            addDebug(`âœ“ ä½¿ç”¨ TURN ä¸­ç»§ï¼`);
          } else if (type === 'srflx') {
            candidateTypes.srflx++;
            console.log('[SIMPLEPEER] âœ“ Server reflexive (STUN succeeded)');
            addDebug(`âœ“ STUN æˆåŠŸ`);
          } else if (type === 'host') {
            candidateTypes.host++;
            console.log('[SIMPLEPEER] â„¹ Host candidate (local IP)');
            addDebug(`â„¹ ä¸»æœºå€™é€‰`);
          } else if (type === 'prflx') {
            candidateTypes.prflx++;
            console.log('[SIMPLEPEER] â„¹ Peer reflexive');
            addDebug(`â„¹ å¯¹ç­‰åå°„`);
          }
        } else {
          // æ”¶é›†å®Œæˆ
          if (iceGatheringTimeout) clearTimeout(iceGatheringTimeout);
          console.log(`[SIMPLEPEER] ICE gathering complete (total: ${candidateCount} candidates)`);
          addDebug(`âœ… ICE æ”¶é›†å®Œæˆï¼Œå…± ${candidateCount} ä¸ªå€™é€‰`);
          addDebug(`ğŸ“Š å€™é€‰ç±»å‹ç»Ÿè®¡ï¼š`);
          addDebug(`  - host (æœ¬åœ°): ${candidateTypes.host}`);
          addDebug(`  - srflx (STUN): ${candidateTypes.srflx}`);
          addDebug(`  - relay (TURN): ${candidateTypes.relay}`);
          addDebug(`  - prflx (å¯¹ç­‰åå°„): ${candidateTypes.prflx}`);
          if (candidateCount === 0) {
            console.error('[SIMPLEPEER] No ICE candidates gathered - check network!');
            addDebug(`âŒ æœªæ”¶é›†åˆ°ä»»ä½• ICE å€™é€‰ï¼`);
          } else if (candidateTypes.relay === 0 && candidateTypes.srflx === 0) {
            addDebug(`âš ï¸ åªæœ‰æœ¬åœ°å€™é€‰ï¼ˆhostï¼‰ï¼Œæ— æ³•ç©¿é€ NATï¼`);
            addDebug(`ğŸ’¡ å»ºè®®ï¼šæ£€æŸ¥ TURN æœåŠ¡å™¨æˆ–å…³é—­ VPN`);
          } else if (candidateTypes.relay > 0) {
            addDebug(`âœ… æœ‰ TURN å€™é€‰ï¼Œå³ä½¿ P2P å¤±è´¥ä¹Ÿèƒ½é€šè¿‡ä¸­ç»§è¿æ¥`);
          }
        }
      };
    }
  });

  p.on('data', (data) => {
    logEvent('data');
    onMessage('remote', data.toString());
  });

  p.on('close', () => {
    logEvent('close');
    console.log('[SIMPLEPEER] P2P closed gracefully');
    callDisconnect('peer-left');
  });

  p.on('error', (err) => {
    logEvent('error');
    const errMsg = err?.message || err?.toString() || '';
    addDebug(`âŒ Peer é”™è¯¯: ${errMsg}`);
    addDebug(`ğŸ“‹ é”™è¯¯å †æ ˆ: ${err?.stack || 'æ— å †æ ˆ'}`);
    console.error('[SIMPLEPEER] P2P error:', err);
    if (errMsg.includes('Ice connection failed')) {
      callDisconnect('peer-left');
    } else {
      callDisconnect('network-error');
    }
  });

  // è®¾ç½® ICE è¿æ¥è¶…æ—¶ï¼ˆç§»åŠ¨ç«¯éœ€è¦æ›´é•¿æ—¶é—´ï¼‰
  // GitHub ç ”ç©¶æ˜¾ç¤ºç§»åŠ¨ç«¯ + VPN éœ€è¦ 60-120 ç§’æ‰èƒ½å®Œæˆ ICE æ”¶é›†
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const timeoutMs = isMobile ? 120000 : 45000; // ç§»åŠ¨ç«¯ 120 ç§’ï¼Œæ¡Œé¢ 45 ç§’
  addDebug(`â±ï¸ è¿æ¥è¶…æ—¶è®¾ç½®: ${timeoutMs / 1000} ç§’ (ç§»åŠ¨ç«¯: ${isMobile})`);

  connectionTimeout = setTimeout(() => {
    if (!p.connected) {
      console.error('[SIMPLEPEER] Connection timeout after', timeoutMs / 1000, 'seconds');
      callDisconnect('connection-timeout');
    }
  }, timeoutMs);
}

export function connectSimplePeer(
  targetPeerId: string,
  onMessage: (peerId: string, data: string) => void,
  onConnect: (remotePeerId?: string) => void,
  onDisconnect?: (reason?: string) => void
) {
  addDebug(`ğŸ”— å¼€å§‹ P2P è¿æ¥ï¼Œç›®æ ‡ ID: ${targetPeerId}`);
  console.log('[SIMPLEPEER] Connecting to:', targetPeerId);
  console.log('[SIMPLEPEER] WebSocket state:', ws?.readyState, '(0=CONNECTING, 1=OPEN, 2=CLOSING, 3=CLOSED)');

  // æ£€æŸ¥ WebSocket æ˜¯å¦å·²è¿æ¥
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    addDebug(`âŒ WebSocket æœªå°±ç»ª! State: ${ws?.readyState}`);
    console.error('[SIMPLEPEER] WebSocket not ready! State:', ws?.readyState);
    if (onDisconnect) {
      onDisconnect('network-error');
    }
    return;
  }

  remotePeerId = targetPeerId;

  // ç§»åŠ¨ç«¯æ£€æµ‹å’Œé…ç½®
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  console.log('[SIMPLEPEER] Device type:', isMobile ? 'MOBILE' : 'DESKTOP');
  console.log('[SIMPLEPEER] My ID:', myId);
  console.log('[SIMPLEPEER] Target ID:', targetPeerId);

  const turnServers = getTURNServers();
  addDebug(`ğŸ“¡ åˆ›å»º P2P è¿æ¥ (initiator: true)`);
  addDebug(`ğŸ”„ ICE ç­–ç•¥: ${isMobile ? 'relay (mobile)' : 'all (desktop)'}`);
  addDebug(`ğŸŒ TURN æœåŠ¡å™¨æ•°é‡: ${turnServers.length}`);
  addDebug(`ğŸ“¦ ICE å€™é€‰æ± å¤§å°: ${isMobile ? 10 : 5}`);
  addDebug(`â±ï¸ ICE è¶…æ—¶: ${isMobile ? 60000 : 45000}ms`);
  console.log('[SIMPLEPEER] Creating peer (initiator: true)');
  console.log('[SIMPLEPEER] ICE transport policy:', isMobile ? 'relay (mobile)' : 'all (desktop)');
  console.log('[SIMPLEPEER] ICE candidate pool size:', isMobile ? 10 : 5);
  console.log('[SIMPLEPEER] ICE complete timeout:', isMobile ? 60000 : 45000);
  console.log('[SIMPLEPEER] TURN servers:', turnServers.length);
  turnServers.forEach((server, i) => {
    const url = Array.isArray(server.urls) ? server.urls.join(', ') : server.urls;
    console.log(`[SIMPLEPEER]   ${i + 1}. ${url}`);
  });

  peer = new SimplePeer({
    initiator: true,
    iceCompleteTimeout: isMobile ? 60000 : 45000,  // ç§»åŠ¨ç«¯ 60 ç§’è¶…æ—¶
    config: {
      iceServers: turnServers,
      iceCandidatePoolSize: isMobile ? 10 : 5,  // ç§»åŠ¨ç«¯æ”¶é›†æ›´å¤šå€™é€‰
      iceTransportPolicy: isMobile ? 'relay' : 'all',  // ç§»åŠ¨ç«¯å¼ºåˆ¶ä¸­ç»§
      bundlePolicy: 'max-bundle',  // ä¼˜åŒ–å¸¦å®½
      rtcpMuxPolicy: 'require',  // ä¼˜åŒ–è¿æ¥
    },
    // æ·»åŠ æ›´å¤šè°ƒè¯•é€‰é¡¹
    channelConfig: {},
    channelName: 'ghostchat',
    offerOptions: {
      offerToReceiveAudio: false,
      offerToReceiveVideo: false
    },
    // ç§»åŠ¨ç«¯ä¼˜åŒ– - åˆå¹¶ sdpTransform
    sdpTransform: (sdp: string) => {
      addDebug(`ğŸ“œ SDP Transform è§¦å‘ (é•¿åº¦: ${sdp.length})`);
      // ç§»é™¤å¸¦å®½é™åˆ¶
      return sdp.replace(/b=AS:\d+/g, '');
    }
  });

  addDebug(`âœ… Peer å¯¹è±¡å·²åˆ›å»º`);
  addDebug(`ğŸ“¦ Peer ç±»å‹: SimplePeer`);
  addDebug(`ğŸ” æ£€æŸ¥å†…éƒ¨ _pc å¯¹è±¡...`);

  // å»¶è¿Ÿæ£€æŸ¥ peer å†…éƒ¨çŠ¶æ€
  setTimeout(() => {
    try {
      const internalPc = (peer as any)._pc;
      if (internalPc) {
        addDebug(`âœ… å†…éƒ¨ RTCPeerConnection å­˜åœ¨`);
        addDebug(`ğŸ”§ RTCPeerConnection çŠ¶æ€: ${internalPc.connectionState || 'unknown'}`);
        addDebug(`ğŸ§Š ICE çŠ¶æ€: ${internalPc.iceConnectionState || 'unknown'}`);
        addDebug(`ğŸ“¦ ICE æ”¶é›†çŠ¶æ€: ${internalPc.iceGatheringState || 'unknown'}`);

        // æ£€æŸ¥æ‰€æœ‰å±æ€§
        const properties = ['localDescription', 'remoteDescription', 'currentLocalDescription', 'currentRemoteDescription'];
        properties.forEach(prop => {
          const value = (internalPc as any)[prop];
          const hasValue = value ? 'âœ“' : 'âœ—';
          addDebug(`  ${hasValue} ${prop}: ${value ? 'å·²è®¾ç½®' : 'æœªè®¾ç½®'}`);
        });
      } else {
        addDebug(`âŒ å†…éƒ¨ RTCPeerConnection ä¸å­˜åœ¨ï¼`);
      }
    } catch (e) {
      addDebug(`âŒ æ£€æŸ¥ peer å†…éƒ¨çŠ¶æ€å‡ºé”™: ${e}`);
    }
  }, 500);

  setupPeer(peer, onMessage, onConnect, onDisconnect, targetPeerId);
}

export function sendSimplePeer(data: string) {
  if (peer) {
    peer.send(data);
  }
}

export function destroySimplePeer() {
  stopHeartbeat(); // åœæ­¢å¿ƒè·³
  peer?.destroy();
  ws?.close();
  peer = null;
  ws = null;
  myId = null;
  remotePeerId = null;
  storedOnMessage = null;
  storedOnConnect = null;
  storedOnDisconnect = undefined;
  p2pEstablished = false; // é‡ç½®P2Pè¿æ¥æ ‡å¿—
  reconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°
  currentWorkerUrl = ''; // æ¸…ç©º worker URL

  // æ¸…é™¤ä¿å­˜çš„ IDï¼ˆç”¨æˆ·ä¸»åŠ¨é€€å‡ºæ—¶ï¼‰
  try {
    localStorage.removeItem('ghostchat_peer_id');
    localStorage.removeItem('ghostchat_peer_id_timestamp');
    console.log('[SIMPLEPEER] ğŸ—‘ï¸ å·²æ¸…é™¤ä¿å­˜çš„ ID');
  } catch (e) {
    // ignore
  }
}

// é¡µé¢å¯è§æ€§æ£€æµ‹ - å½“ä»åå°æ¢å¤æ—¶æ£€æŸ¥è¿æ¥çŠ¶æ€
if (typeof document !== 'undefined') {
  let wasHidden = false;

  document.addEventListener('visibilitychange', () => {
    const isHidden = document.hidden;

    if (isHidden) {
      // é¡µé¢è¿›å…¥åå°
      wasHidden = true;
      addDebug(`ğŸŒ‘ é¡µé¢è¿›å…¥åå°`);
      console.log('[SIMPLEPEER] Page hidden, connection may be suspended');
    } else if (wasHidden) {
      // é¡µé¢ä»åå°æ¢å¤
      wasHidden = false;
      addDebug(`â˜€ï¸ é¡µé¢ä»åå°æ¢å¤`);
      console.log('[SIMPLEPEER] Page visible again, checking connection...');

      // æ£€æŸ¥ WebSocket çŠ¶æ€
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        addDebug(`âŒ WebSocket å·²æ–­å¼€ï¼Œå°è¯•é‡è¿...`);
        console.log('[SIMPLEPEER] WebSocket closed, attempting to reconnect with saved ID...');

        // å°è¯•ä½¿ç”¨ä¿å­˜çš„ ID é‡è¿
        const savedId = getSavedId();
        if (savedId && storedOnMessage && storedOnConnect && storedOnDisconnect) {
          // ä½¿ç”¨å½“å‰ worker URL é‡è¿
          tryConnectWorker(currentWorkerUrl, storedOnMessage, storedOnConnect, storedOnDisconnect)
            .then(newId => {
              addDebug(`âœ… é‡è¿æˆåŠŸï¼ŒID: ${newId}`);
              console.log('[SIMPLEPEER] Reconnected with ID:', newId);
            })
            .catch(err => {
              addDebug(`âŒ é‡è¿å¤±è´¥: ${err}`);
              console.error('[SIMPLEPEER] Reconnect failed:', err);
            });
        }
      } else if (ws && ws.readyState === WebSocket.OPEN) {
        addDebug(`âœ… WebSocket ä»ç„¶è¿æ¥æ­£å¸¸`);
        console.log('[SIMPLEPEER] WebSocket still connected');
      }
    }
  });

  console.log('[SIMPLEPEER] âœ… Page Visibility API å·²å¯ç”¨');
}

