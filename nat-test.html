<!DOCTYPE html>
<html>
<head>
  <title>WebRTC NAT è¯Šæ–­</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .result { margin: 10px 0; padding: 15px; border-radius: 5px; }
    .success { background: #d4edda; border: 1px solid #c3e6cb; }
    .error { background: #f8d7da; border: 1px solid #f5c6cb; }
    .info { background: #d1ecf1; border: 1px solid #bee5eb; }
    .loading { background: #fff3cd; border: 1px solid #ffeaa7; }
    h2 { margin-top: 0; }
  </style>
</head>
<body>
  <h1>ğŸ§ª WebRTC NAT è¯Šæ–­å·¥å…·</h1>

  <button onclick="startTest()">å¼€å§‹æµ‹è¯•</button>

  <div id="results"></div>

  <script>
    async function startTest() {
      const results = document.getElementById('results');
      results.innerHTML = '<div class="result loading">æ­£åœ¨æµ‹è¯•...è¯·ç­‰å¾…</div>';

      const stunServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ];

      // æµ‹è¯• 1: STUN æœåŠ¡å™¨å¯è¾¾æ€§
      let stunResults = [];
      for (const server of stunServers) {
        try {
          const pc = new RTCPeerConnection({ iceServers: [server] });
          await new Promise((resolve, reject) => {
            pc.onicecandidate = (e) => {
              if (e.candidate) {
                stunResults.push({
                  server: server.urls,
                  success: true,
                  type: e.candidate.type,
                  address: e.candidate.address
                });
                pc.close();
                resolve();
              }
            };
            pc.onicecandidateerror = () => {
              stunResults.push({
                server: server.urls,
                success: false,
                error: 'ICE candidate error'
              });
              pc.close();
              resolve();
            };
            setTimeout(() => {
              stunResults.push({
                server: server.urls,
                success: false,
                error: 'Timeout'
              });
              pc.close();
              resolve();
            }, 5000);
          });
        } catch (e) {
          stunResults.push({
            server: server.urls,
            success: false,
            error: e.message
          });
        }
      }

      // æµ‹è¯• 2: æ”¶é›† ICE å€™é€‰
      let iceCandidates = [];
      try {
        const pc = new RTCPeerConnection({ iceServers: stunServers });
        await new Promise((resolve, reject) => {
          let candidateCount = 0;
          pc.onicecandidate = (e) => {
            if (e.candidate) {
              candidateCount++;
              iceCandidates.push({
                type: e.candidate.type,
                protocol: e.candidate.protocol,
                address: e.candidate.address,
                port: e.candidate.port
              });
            } else {
              setTimeout(() => {
                pc.close();
                resolve();
              }, 2000);
            }
          };
          pc.onicecandidateerror = () => {
            pc.close();
            resolve();
          };
          setTimeout(() => {
            pc.close();
            resolve();
          }, 10000);
        });
      } catch (e) {
        console.error('ICE test failed:', e);
      }

      // æ˜¾ç¤ºç»“æœ
      let html = '<h2>ğŸ“Š æµ‹è¯•ç»“æœ</h2>';

      html += '<h3>STUN æœåŠ¡å™¨æµ‹è¯•</h3>';
      for (const result of stunResults) {
        const className = result.success ? 'success' : 'error';
        html += `<div class="result ${className}">
          <strong>${result.server}</strong><br>
          çŠ¶æ€: ${result.success ? 'âœ… å¯è¾¾' : 'âŒ ä¸å¯è¾¾'}<br>
          ${result.address ? `åœ°å€: ${result.address}` : ''}
          ${result.error ? `é”™è¯¯: ${result.error}` : ''}
        </div>`;
      }

      html += '<h3>ICE å€™é€‰æ”¶é›†</h3>';
      if (iceCandidates.length === 0) {
        html += '<div class="result error">æœªæ”¶é›†åˆ°ä»»ä½• ICE å€™é€‰ï¼NAT å¯èƒ½å®Œå…¨é˜»æ­¢è¿æ¥ã€‚</div>';
      } else {
        const candidateTypes = { host: 0, srflx: 0, relay: 0 };
        for (const c of iceCandidates) {
          if (candidateTypes[c.type] !== undefined) {
            candidateTypes[c.type]++;
          }
        }
        html += '<div class="result info">';
        html += `<strong>æ€»å€™é€‰æ•°:</strong> ${iceCandidates.length}<br>`;
        html += `<strong>å€™é€‰ç±»å‹:</strong><br>`;
        html += `- Host (æœ¬åœ°): ${candidateTypes.host || 0}<br>`;
        html += `- Server Reflexive (STUN): ${candidateTypes.srflx || 0}<br>`;
        html += `- Relay (TURN): ${candidateTypes.relay || 0}<br>`;
        html += '</div>';

        if (candidateTypes.relay === 0) {
          html += '<div class="result error">âš ï¸ æ²¡æœ‰ TURN å€™é€‰ï¼è¿æ¥å¯èƒ½å¤±è´¥ã€‚</div>';
        }
      }

      html += '<h3>å»ºè®®</h3>';
      if (iceCandidates.length === 0 || candidateTypes.relay === 0) {
        html += '<div class="result info">';
        html += '<strong>TURN æœåŠ¡å™¨å¯èƒ½æ— æ³•è®¿é—®ï¼</strong><br>';
        html += 'è¯·æ£€æŸ¥ï¼š<br>';
        html += '1. ç«¯å£ 3478/5349 æ˜¯å¦å¼€æ”¾<br>';
        html += '2. é˜²ç«å¢™æ˜¯å¦é˜»æ­¢ UDP/TCP<br>';
        html += '3. TURN æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œ<br>';
        html += '</div>';
      } else {
        html += '<div class="result success">âœ… TURN æœåŠ¡å™¨å¯è¾¾ï¼å¯ä»¥å°è¯•è¿æ¥ GhostChatã€‚</div>';
      }

      results.innerHTML = html;
    }
  </script>
</body>
</html>
